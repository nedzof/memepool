"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_js_1 = require("../primitives/index.js");
const ProtoWallet_js_1 = __importDefault(require("../wallet/ProtoWallet.js"));
/**
 * Represents an Identity Certificate as per the Wallet interface specifications.
 *
 * This class provides methods to serialize and deserialize certificates, as well as signing and verifying the certificate's signature.
 */
class Certificate {
    /**
     * Constructs a new Certificate.
     *
     * @param {Base64String} type - Type identifier for the certificate, base64 encoded string, 32 bytes.
     * @param {Base64String} serialNumber - Unique serial number of the certificate, base64 encoded string, 32 bytes.
     * @param {PubKeyHex} subject - The public key belonging to the certificate's subject, compressed public key hex string.
     * @param {PubKeyHex} certifier - Public key of the certifier who issued the certificate, compressed public key hex string.
     * @param {OutpointString} revocationOutpoint - The outpoint used to confirm that the certificate has not been revoked (TXID.OutputIndex), as a string.
     * @param {Record<CertificateFieldNameUnder50Bytes, string>} fields - All the fields present in the certificate.
     * @param {HexString} signature - Certificate signature by the certifier's private key, DER encoded hex string.
     */
    constructor(type, serialNumber, subject, certifier, revocationOutpoint, fields, signature) {
        this.type = type;
        this.serialNumber = serialNumber;
        this.subject = subject;
        this.certifier = certifier;
        this.revocationOutpoint = revocationOutpoint;
        this.fields = fields;
        this.signature = signature;
    }
    /**
     * Serializes the certificate into binary format, with or without a signature.
     *
     * @param {boolean} [includeSignature=true] - Whether to include the signature in the serialization.
     * @returns {number[]} - The serialized certificate in binary format.
     */
    toBin(includeSignature = true) {
        const writer = new index_js_1.Utils.Writer();
        // Write type (Base64String, 32 bytes)
        const typeBytes = index_js_1.Utils.toArray(this.type, 'base64');
        writer.write(typeBytes);
        // Write serialNumber (Base64String, 32 bytes)
        const serialNumberBytes = index_js_1.Utils.toArray(this.serialNumber, 'base64');
        writer.write(serialNumberBytes);
        // Write subject (33 bytes compressed PubKeyHex)
        const subjectBytes = index_js_1.Utils.toArray(this.subject, 'hex');
        writer.write(subjectBytes);
        // Write certifier (33 bytes compressed PubKeyHex)
        const certifierBytes = index_js_1.Utils.toArray(this.certifier, 'hex');
        writer.write(certifierBytes);
        // Write revocationOutpoint (TXID + OutputIndex)
        const [txid, outputIndex] = this.revocationOutpoint.split('.');
        const txidBytes = index_js_1.Utils.toArray(txid, 'hex');
        writer.write(txidBytes);
        writer.writeVarIntNum(Number(outputIndex));
        // Write fields
        const fieldEntries = Object.entries(this.fields);
        writer.writeVarIntNum(fieldEntries.length);
        for (const [fieldName, fieldValue] of fieldEntries) {
            // Field name
            const fieldNameBytes = index_js_1.Utils.toArray(fieldName, 'utf8');
            writer.writeVarIntNum(fieldNameBytes.length);
            writer.write(fieldNameBytes);
            // Field value
            const fieldValueBytes = index_js_1.Utils.toArray(fieldValue, 'utf8');
            writer.writeVarIntNum(fieldValueBytes.length);
            writer.write(fieldValueBytes);
        }
        // Write signature if included
        if (includeSignature && this.signature && this.signature.length > 0) {
            const signatureBytes = index_js_1.Utils.toArray(this.signature, 'hex');
            writer.writeVarIntNum(signatureBytes.length);
            writer.write(signatureBytes);
        }
        return writer.toArray();
    }
    /**
     * Deserializes a certificate from binary format.
     *
     * @param {number[]} bin - The binary data representing the certificate.
     * @returns {Certificate} - The deserialized Certificate object.
     */
    static fromBin(bin) {
        const reader = new index_js_1.Utils.Reader(bin);
        // Read type
        const typeBytes = reader.read(32);
        const type = index_js_1.Utils.toBase64(typeBytes);
        // Read serialNumber
        const serialNumberBytes = reader.read(32);
        const serialNumber = index_js_1.Utils.toBase64(serialNumberBytes);
        // Read subject (33 bytes)
        const subjectBytes = reader.read(33);
        const subject = index_js_1.Utils.toHex(subjectBytes);
        // Read certifier (33 bytes)
        const certifierBytes = reader.read(33);
        const certifier = index_js_1.Utils.toHex(certifierBytes);
        // Read revocationOutpoint
        const txidBytes = reader.read(32);
        const txid = index_js_1.Utils.toHex(txidBytes);
        const outputIndex = reader.readVarIntNum();
        const revocationOutpoint = `${txid}.${outputIndex}`;
        // Read fields
        const numFields = reader.readVarIntNum();
        const fields = {};
        for (let i = 0; i < numFields; i++) {
            // Field name
            const fieldNameLength = reader.readVarIntNum();
            const fieldNameBytes = reader.read(fieldNameLength);
            const fieldName = index_js_1.Utils.toUTF8(fieldNameBytes);
            // Field value
            const fieldValueLength = reader.readVarIntNum();
            const fieldValueBytes = reader.read(fieldValueLength);
            const fieldValue = index_js_1.Utils.toUTF8(fieldValueBytes);
            fields[fieldName] = fieldValue;
        }
        // Read signature if present
        let signature;
        if (!reader.eof()) {
            const signatureLength = reader.readVarIntNum();
            const signatureBytes = reader.read(signatureLength);
            signature = index_js_1.Utils.toHex(signatureBytes);
        }
        return new Certificate(type, serialNumber, subject, certifier, revocationOutpoint, fields, signature);
    }
    /**
     * Verifies the certificate's signature.
     *
     * @returns {Promise<boolean>} - A promise that resolves to true if the signature is valid.
     */
    async verify() {
        // A verifier can be any wallet capable of verifying signatures
        const verifier = new ProtoWallet_js_1.default('anyone');
        const verificationData = this.toBin(false); // Exclude the signature from the verification data
        const { valid } = await verifier.verifySignature({
            signature: index_js_1.Utils.toArray(this.signature, 'hex'),
            data: verificationData,
            protocolID: [2, 'certificate signature'],
            keyID: `${this.type} ${this.serialNumber}`,
            counterparty: this.certifier // The certifier is the one who signed the certificate
        });
        return valid;
    }
    /**
     * Signs the certificate using the provided certifier wallet.
     *
     * @param {Wallet} certifier - The wallet representing the certifier.
     * @returns {Promise<void>}
     */
    async sign(certifier) {
        const preimage = this.toBin(false); // Exclude the signature when signing
        const { signature } = await certifier.createSignature({
            data: preimage,
            protocolID: [2, 'certificate signature'],
            keyID: `${this.type} ${this.serialNumber}`
        });
        this.signature = index_js_1.Utils.toHex(signature);
    }
}
exports.default = Certificate;
//# sourceMappingURL=Certificate.js.map