"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const KeyDeriver_js_1 = __importDefault(require("./KeyDeriver.js"));
const index_js_1 = require("../primitives/index.js");
const WalletError_js_1 = __importStar(require("./WalletError.js"));
/**
 * A ProtoWallet is a structure that fulfills the Wallet interface, capable of performing all foundational cryptographic operations. It can derive keys, create signatures, facilitate encryption and HMAC operations, and reveal key linkages. However, ProtoWallet does not create transactions, manage outputs, interact with the blockchain, enable the management of identity certificates, or store any data.
 */
class ProtoWallet {
    constructor(rootKey, KeyDeriverClass = KeyDeriver_js_1.default) {
        this.privilegedError = 'ProtoWallet is a single-keyring wallet, operating without context about whether its configured keyring is privileged.';
        this.keyDeriver = new KeyDeriverClass(rootKey);
    }
    async createAction(args, originator) {
        throw new WalletError_js_1.WalletError('ProtoWallet does not support creating transactions.', WalletError_js_1.default.unsupportedAction);
    }
    async signAction(args, originator) {
        throw new WalletError_js_1.WalletError('ProtoWallet does not support creating transactions.', WalletError_js_1.default.unsupportedAction);
    }
    async abortAction(args, originator) {
        throw new WalletError_js_1.WalletError('ProtoWallet does not support aborting transactions.', WalletError_js_1.default.unsupportedAction);
    }
    async listActions(args, originator) {
        throw new WalletError_js_1.WalletError('ProtoWallet does not support retrieving transactions.', WalletError_js_1.default.unsupportedAction);
    }
    async internalizeAction(args, originator) {
        throw new WalletError_js_1.WalletError('ProtoWallet does not support internalizing transactions.', WalletError_js_1.default.unsupportedAction);
    }
    async listOutputs(args, originator) {
        throw new WalletError_js_1.WalletError('ProtoWallet does not support retrieving outputs.', WalletError_js_1.default.unsupportedAction);
    }
    async relinquishOutput(args, originator) {
        throw new WalletError_js_1.WalletError('ProtoWallet does not support deleting outputs.', WalletError_js_1.default.unsupportedAction);
    }
    async getPublicKey(args, originator) {
        if (args.privileged) {
            throw new WalletError_js_1.WalletError(this.privilegedError);
        }
        if (args.identityKey) {
            return { publicKey: this.keyDeriver.rootKey.toPublicKey().toString() };
        }
        else {
            return {
                publicKey: this.keyDeriver
                    .derivePublicKey(args.protocolID, args.keyID, args.counterparty || 'self', args.forSelf)
                    .toString()
            };
        }
    }
    async revealCounterpartyKeyLinkage(args, originator) {
        if (args.privileged) {
            throw new WalletError_js_1.WalletError(this.privilegedError);
        }
        const { publicKey: identityKey } = await this.getPublicKey({ identityKey: true });
        const linkage = this.keyDeriver.revealCounterpartySecret(args.counterparty);
        const linkageProof = new index_js_1.Schnorr().generateProof(this.keyDeriver.rootKey, this.keyDeriver.rootKey.toPublicKey(), index_js_1.PublicKey.fromString(args.counterparty), index_js_1.Point.fromDER(linkage));
        const linkageProofBin = [
            ...linkageProof.R.encode(true),
            ...linkageProof.SPrime.encode(true),
            ...linkageProof.z.toArray()
        ];
        const revelationTime = new Date().toISOString();
        const { ciphertext: encryptedLinkage } = await this.encrypt({
            plaintext: linkage,
            protocolID: [2, 'counterparty linkage revelation'],
            keyID: revelationTime,
            counterparty: args.verifier
        });
        const { ciphertext: encryptedLinkageProof } = await this.encrypt({
            plaintext: linkageProofBin,
            protocolID: [2, 'counterparty linkage revelation'],
            keyID: revelationTime,
            counterparty: args.verifier
        });
        return {
            prover: identityKey,
            verifier: args.verifier,
            counterparty: args.counterparty,
            revelationTime,
            encryptedLinkage,
            encryptedLinkageProof
        };
    }
    async revealSpecificKeyLinkage(args, originator) {
        if (args.privileged) {
            throw new WalletError_js_1.WalletError(this.privilegedError);
        }
        const { publicKey: identityKey } = await this.getPublicKey({ identityKey: true });
        const linkage = this.keyDeriver.revealSpecificSecret(args.counterparty, args.protocolID, args.keyID);
        const { ciphertext: encryptedLinkage } = await this.encrypt({
            plaintext: linkage,
            protocolID: [2, `specific linkage revelation ${args.protocolID[0]} ${args.protocolID[1]}`],
            keyID: args.keyID,
            counterparty: args.verifier
        });
        const { ciphertext: encryptedLinkageProof } = await this.encrypt({
            plaintext: [0], // Proof type 0, no proof provided
            protocolID: [2, `specific linkage revelation ${args.protocolID[0]} ${args.protocolID[1]}`],
            keyID: args.keyID,
            counterparty: args.verifier
        });
        return {
            prover: identityKey,
            verifier: args.verifier,
            counterparty: args.counterparty,
            protocolID: args.protocolID,
            keyID: args.keyID,
            encryptedLinkage,
            encryptedLinkageProof,
            proofType: 0
        };
    }
    async encrypt(args, originator) {
        if (args.privileged) {
            throw new WalletError_js_1.WalletError(this.privilegedError);
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty || 'self');
        return { ciphertext: key.encrypt(args.plaintext) };
    }
    async decrypt(args, originator) {
        if (args.privileged) {
            throw new WalletError_js_1.WalletError(this.privilegedError);
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty || 'self');
        return { plaintext: key.decrypt(args.ciphertext) };
    }
    async createHmac(args, originator) {
        if (args.privileged) {
            throw new WalletError_js_1.WalletError(this.privilegedError);
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty || 'self');
        return { hmac: index_js_1.Hash.sha256hmac(key.toArray(), args.data) };
    }
    async verifyHmac(args, originator) {
        if (args.privileged) {
            throw new WalletError_js_1.WalletError(this.privilegedError);
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty || 'self');
        const valid = index_js_1.Hash.sha256hmac(key.toArray(), args.data).toString() === args.hmac.toString();
        if (!valid) {
            throw new WalletError_js_1.WalletError('HMAC is not valid', WalletError_js_1.default.invalidHmac);
        }
        return { valid };
    }
    async createSignature(args, originator) {
        if (args.privileged) {
            throw new WalletError_js_1.WalletError(this.privilegedError);
        }
        let hash = args.hashToDirectlySign;
        if (!hash) {
            hash = index_js_1.Hash.sha256(args.data);
        }
        const key = this.keyDeriver.derivePrivateKey(args.protocolID, args.keyID, args.counterparty || 'anyone');
        return { signature: index_js_1.ECDSA.sign(new index_js_1.BigNumber(hash), key, true).toDER() };
    }
    async verifySignature(args, originator) {
        if (args.privileged) {
            throw new WalletError_js_1.WalletError(this.privilegedError);
        }
        let hash = args.hashToDirectlyVerify;
        if (!hash) {
            hash = index_js_1.Hash.sha256(args.data);
        }
        const key = this.keyDeriver.derivePublicKey(args.protocolID, args.keyID, args.counterparty || 'self', args.forSelf);
        const valid = index_js_1.ECDSA.verify(new index_js_1.BigNumber(hash), index_js_1.Signature.fromDER(args.signature), key);
        if (!valid) {
            throw new WalletError_js_1.WalletError('Signature is not valid', WalletError_js_1.default.invalidSignature);
        }
        return { valid };
    }
    async acquireCertificate(args, originator) {
        throw new WalletError_js_1.WalletError('ProtoWallet does not support acquiring certificates.', WalletError_js_1.default.unsupportedAction);
    }
    async listCertificates(args, originator) {
        throw new WalletError_js_1.WalletError('ProtoWallet does not support retrieving certificates.', WalletError_js_1.default.unsupportedAction);
    }
    async proveCertificate(args, originator) {
        throw new WalletError_js_1.WalletError('ProtoWallet does not support proving certificates.', WalletError_js_1.default.unsupportedAction);
    }
    async relinquishCertificate(args, originator) {
        throw new WalletError_js_1.WalletError('ProtoWallet does not support deleting certificates.', WalletError_js_1.default.unsupportedAction);
    }
    async discoverByIdentityKey(args, originator) {
        throw new WalletError_js_1.WalletError('ProtoWallet does not support resolving identities.', WalletError_js_1.default.unsupportedAction);
    }
    async discoverByAttributes(args, originator) {
        throw new WalletError_js_1.WalletError('ProtoWallet does not support resolving identities.', WalletError_js_1.default.unsupportedAction);
    }
    async isAuthenticated(args, originator) {
        return { authenticated: true };
    }
    async waitForAuthentication(args, originator) {
        return { authenticated: true };
    }
    async getHeight(args, originator) {
        throw new WalletError_js_1.WalletError('ProtoWallet does not support blockchain tracking.', WalletError_js_1.default.unsupportedAction);
    }
    async getHeaderForHeight(args, originator) {
        throw new WalletError_js_1.WalletError('ProtoWallet does not support blockchain tracking.', WalletError_js_1.default.unsupportedAction);
    }
    async getNetwork(args, originator) {
        return { network: 'mainnet' };
    }
    async getVersion(args, originator) {
        return { version: 'proto-1.0.0' };
    }
}
exports.default = ProtoWallet;
//# sourceMappingURL=ProtoWallet.js.map