import KeyDeriver from './KeyDeriver.js';
import { Hash, ECDSA, BigNumber, Signature, Schnorr, PublicKey, Point } from '../primitives/index.js';
import walletErrors, { WalletError } from './WalletError.js';
/**
 * A ProtoWallet is a structure that fulfills the Wallet interface, capable of performing all foundational cryptographic operations. It can derive keys, create signatures, facilitate encryption and HMAC operations, and reveal key linkages. However, ProtoWallet does not create transactions, manage outputs, interact with the blockchain, enable the management of identity certificates, or store any data.
 */
export default class ProtoWallet {
    keyDeriver;
    privilegedError = 'ProtoWallet is a single-keyring wallet, operating without context about whether its configured keyring is privileged.';
    constructor(rootKey, KeyDeriverClass = KeyDeriver) {
        this.keyDeriver = new KeyDeriverClass(rootKey);
    }
    async createAction(args, originator) {
        throw new WalletError('ProtoWallet does not support creating transactions.', walletErrors.unsupportedAction);
    }
    async signAction(args, originator) {
        throw new WalletError('ProtoWallet does not support creating transactions.', walletErrors.unsupportedAction);
    }
    async abortAction(args, originator) {
        throw new WalletError('ProtoWallet does not support aborting transactions.', walletErrors.unsupportedAction);
    }
    async listActions(args, originator) {
        throw new WalletError('ProtoWallet does not support retrieving transactions.', walletErrors.unsupportedAction);
    }
    async internalizeAction(args, originator) {
        throw new WalletError('ProtoWallet does not support internalizing transactions.', walletErrors.unsupportedAction);
    }
    async listOutputs(args, originator) {
        throw new WalletError('ProtoWallet does not support retrieving outputs.', walletErrors.unsupportedAction);
    }
    async relinquishOutput(args, originator) {
        throw new WalletError('ProtoWallet does not support deleting outputs.', walletErrors.unsupportedAction);
    }
    async getPublicKey(args, originator) {
        if (args.privileged) {
            throw new WalletError(this.privilegedError);
        }
        if (args.identityKey) {
            return { publicKey: this.keyDeriver.rootKey.toPublicKey().toString() };
        }
        else {
            return {
                publicKey: this.keyDeriver
                    .derivePublicKey(args.protocolID, args.keyID, args.counterparty || 'self', args.forSelf)
                    .toString()
            };
        }
    }
    async revealCounterpartyKeyLinkage(args, originator) {
        if (args.privileged) {
            throw new WalletError(this.privilegedError);
        }
        const { publicKey: identityKey } = await this.getPublicKey({ identityKey: true });
        const linkage = this.keyDeriver.revealCounterpartySecret(args.counterparty);
        const linkageProof = new Schnorr().generateProof(this.keyDeriver.rootKey, this.keyDeriver.rootKey.toPublicKey(), PublicKey.fromString(args.counterparty), Point.fromDER(linkage));
        const linkageProofBin = [
            ...linkageProof.R.encode(true),
            ...linkageProof.SPrime.encode(true),
            ...linkageProof.z.toArray()
        ];
        const revelationTime = new Date().toISOString();
        const { ciphertext: encryptedLinkage } = await this.encrypt({
            plaintext: linkage,
            protocolID: [2, 'counterparty linkage revelation'],
            keyID: revelationTime,
            counterparty: args.verifier
        });
        const { ciphertext: encryptedLinkageProof } = await this.encrypt({
            plaintext: linkageProofBin,
            protocolID: [2, 'counterparty linkage revelation'],
            keyID: revelationTime,
            counterparty: args.verifier
        });
        return {
            prover: identityKey,
            verifier: args.verifier,
            counterparty: args.counterparty,
            revelationTime,
            encryptedLinkage,
            encryptedLinkageProof
        };
    }
    async revealSpecificKeyLinkage(args, originator) {
        if (args.privileged) {
            throw new WalletError(this.privilegedError);
        }
        const { publicKey: identityKey } = await this.getPublicKey({ identityKey: true });
        const linkage = this.keyDeriver.revealSpecificSecret(args.counterparty, args.protocolID, args.keyID);
        const { ciphertext: encryptedLinkage } = await this.encrypt({
            plaintext: linkage,
            protocolID: [2, `specific linkage revelation ${args.protocolID[0]} ${args.protocolID[1]}`],
            keyID: args.keyID,
            counterparty: args.verifier
        });
        const { ciphertext: encryptedLinkageProof } = await this.encrypt({
            plaintext: [0], // Proof type 0, no proof provided
            protocolID: [2, `specific linkage revelation ${args.protocolID[0]} ${args.protocolID[1]}`],
            keyID: args.keyID,
            counterparty: args.verifier
        });
        return {
            prover: identityKey,
            verifier: args.verifier,
            counterparty: args.counterparty,
            protocolID: args.protocolID,
            keyID: args.keyID,
            encryptedLinkage,
            encryptedLinkageProof,
            proofType: 0
        };
    }
    async encrypt(args, originator) {
        if (args.privileged) {
            throw new WalletError(this.privilegedError);
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty || 'self');
        return { ciphertext: key.encrypt(args.plaintext) };
    }
    async decrypt(args, originator) {
        if (args.privileged) {
            throw new WalletError(this.privilegedError);
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty || 'self');
        return { plaintext: key.decrypt(args.ciphertext) };
    }
    async createHmac(args, originator) {
        if (args.privileged) {
            throw new WalletError(this.privilegedError);
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty || 'self');
        return { hmac: Hash.sha256hmac(key.toArray(), args.data) };
    }
    async verifyHmac(args, originator) {
        if (args.privileged) {
            throw new WalletError(this.privilegedError);
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty || 'self');
        const valid = Hash.sha256hmac(key.toArray(), args.data).toString() === args.hmac.toString();
        if (!valid) {
            throw new WalletError('HMAC is not valid', walletErrors.invalidHmac);
        }
        return { valid };
    }
    async createSignature(args, originator) {
        if (args.privileged) {
            throw new WalletError(this.privilegedError);
        }
        let hash = args.hashToDirectlySign;
        if (!hash) {
            hash = Hash.sha256(args.data);
        }
        const key = this.keyDeriver.derivePrivateKey(args.protocolID, args.keyID, args.counterparty || 'anyone');
        return { signature: ECDSA.sign(new BigNumber(hash), key, true).toDER() };
    }
    async verifySignature(args, originator) {
        if (args.privileged) {
            throw new WalletError(this.privilegedError);
        }
        let hash = args.hashToDirectlyVerify;
        if (!hash) {
            hash = Hash.sha256(args.data);
        }
        const key = this.keyDeriver.derivePublicKey(args.protocolID, args.keyID, args.counterparty || 'self', args.forSelf);
        const valid = ECDSA.verify(new BigNumber(hash), Signature.fromDER(args.signature), key);
        if (!valid) {
            throw new WalletError('Signature is not valid', walletErrors.invalidSignature);
        }
        return { valid };
    }
    async acquireCertificate(args, originator) {
        throw new WalletError('ProtoWallet does not support acquiring certificates.', walletErrors.unsupportedAction);
    }
    async listCertificates(args, originator) {
        throw new WalletError('ProtoWallet does not support retrieving certificates.', walletErrors.unsupportedAction);
    }
    async proveCertificate(args, originator) {
        throw new WalletError('ProtoWallet does not support proving certificates.', walletErrors.unsupportedAction);
    }
    async relinquishCertificate(args, originator) {
        throw new WalletError('ProtoWallet does not support deleting certificates.', walletErrors.unsupportedAction);
    }
    async discoverByIdentityKey(args, originator) {
        throw new WalletError('ProtoWallet does not support resolving identities.', walletErrors.unsupportedAction);
    }
    async discoverByAttributes(args, originator) {
        throw new WalletError('ProtoWallet does not support resolving identities.', walletErrors.unsupportedAction);
    }
    async isAuthenticated(args, originator) {
        return { authenticated: true };
    }
    async waitForAuthentication(args, originator) {
        return { authenticated: true };
    }
    async getHeight(args, originator) {
        throw new WalletError('ProtoWallet does not support blockchain tracking.', walletErrors.unsupportedAction);
    }
    async getHeaderForHeight(args, originator) {
        throw new WalletError('ProtoWallet does not support blockchain tracking.', walletErrors.unsupportedAction);
    }
    async getNetwork(args, originator) {
        return { network: 'mainnet' };
    }
    async getVersion(args, originator) {
        return { version: 'proto-1.0.0' };
    }
}
//# sourceMappingURL=ProtoWallet.js.map