import { Transaction } from '../transaction/index.js';
import OverlayAdminTokenTemplate from './OverlayAdminTokenTemplate.js';
/** Default SLAP trackers */
export const DEFAULT_SLAP_TRACKERS = [
    // Babbage primary overlay service
    'https://overlay.babbage.systems',
    // Babbage example overlay
    'https://overlay-example.babbage.systems',
    // The Babbage office building
    'https://office.babbage.systems'
    // NOTE: Other entities may submit pull requests to the library if they maintain SLAP overlay services.
    // Additional trackers run by different entities contribute to greater network resiliency.
    // It also generally doesn't hurt to have more trackers in this list.
    // DISCLAIMER:
    // Trackers known to host invalid or illegal records will be removed at the discretion of the BSV Association.
];
const MAX_TRACKER_WAIT_TIME = 1000;
export class HTTPSOverlayLookupFacilitator {
    fetchClient;
    constructor(httpClient = fetch) {
        this.fetchClient = httpClient;
    }
    async lookup(url, question, timeout = 5000) {
        if (!url.startsWith('https:')) {
            throw new Error('HTTPS facilitator can only use URLs that start with "https:"');
        }
        const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Request timed out')), timeout));
        const fetchPromise = fetch(`${url}/lookup`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ service: question.service, query: question.query })
        });
        const response = await Promise.race([fetchPromise, timeoutPromise]);
        if (response.ok) {
            return await response.json();
        }
        else {
            throw new Error('Failed to facilitate lookup');
        }
    }
}
/**
 * Represents an SHIP transaction broadcaster.
 */
export default class LookupResolver {
    facilitator;
    slapTrackers;
    hostOverrides;
    additionalHosts;
    constructor(config) {
        const { facilitator, slapTrackers, hostOverrides, additionalHosts } = config ?? {};
        this.facilitator = facilitator ?? new HTTPSOverlayLookupFacilitator();
        this.slapTrackers = slapTrackers ?? DEFAULT_SLAP_TRACKERS;
        this.hostOverrides = hostOverrides ?? {};
        this.additionalHosts = additionalHosts ?? {};
    }
    /**
     * Given a LookupQuestion, returns a LookupAnswer. Aggregates across multiple services and supports resiliency.
     */
    async query(question, timeout) {
        let competentHosts = [];
        if (question.service === 'ls_slap') {
            competentHosts = this.slapTrackers;
        }
        else if (this.hostOverrides[question.service]) {
            competentHosts = this.hostOverrides[question.service];
        }
        else {
            competentHosts = await this.findCompetentHosts(question.service);
        }
        if (this.additionalHosts[question.service]) {
            competentHosts = [
                ...competentHosts,
                ...this.additionalHosts[question.service]
            ];
        }
        if (competentHosts.length < 1) {
            throw new Error(`No competent hosts found by the SLAP trackers for lookup service: ${question.service}`);
        }
        // Use Promise.allSettled to handle individual host failures
        const hostResponses = await Promise.allSettled(competentHosts.map(async (host) => await this.facilitator.lookup(host, question, timeout)));
        const successfulResponses = hostResponses
            .filter(result => result.status === 'fulfilled')
            .map(result => (result).value);
        if (successfulResponses.length === 0) {
            throw new Error('No successful responses from any hosts');
        }
        // Process the successful responses
        if (successfulResponses[0].type === 'freeform') {
            // Return the first freeform response
            return successfulResponses[0];
        }
        else {
            // Aggregate outputs from all successful responses
            const outputs = new Map();
            for (const response of successfulResponses) {
                if (response.type !== 'output-list') {
                    continue;
                }
                try {
                    for (const output of response.outputs) {
                        try {
                            const key = `${Transaction.fromBEEF(output.beef).id('hex')}.${output.outputIndex}`;
                            outputs.set(key, output);
                        }
                        catch (e) {
                            continue;
                        }
                    }
                }
                catch (e) {
                    continue;
                }
            }
            return {
                type: 'output-list',
                outputs: Array.from(outputs.values())
            };
        }
    }
    /**
       * Returns a list of competent hosts for a given lookup service.
       * @param service Service for which competent hosts are to be returned
       * @returns Array of hosts competent for resolving queries
       */
    async findCompetentHosts(service) {
        const query = {
            service: 'ls_slap',
            query: {
                service
            }
        };
        // Use Promise.allSettled to handle individual SLAP tracker failures
        const trackerResponses = await Promise.allSettled(this.slapTrackers.map(async (tracker) => await this.facilitator.lookup(tracker, query, MAX_TRACKER_WAIT_TIME)));
        const hosts = new Set();
        for (const result of trackerResponses) {
            if (result.status === 'fulfilled') {
                const answer = result.value;
                if (answer.type !== 'output-list') {
                    // Log invalid response and continue
                    continue;
                }
                for (const output of answer.outputs) {
                    try {
                        const tx = Transaction.fromBEEF(output.beef);
                        const script = tx.outputs[output.outputIndex].lockingScript;
                        const parsed = OverlayAdminTokenTemplate.decode(script);
                        if (parsed.topicOrService !== service || parsed.protocol !== 'SLAP') {
                            // Invalid advertisement, skip
                            continue;
                        }
                        hosts.add(parsed.domain);
                    }
                    catch (e) {
                        // Invalid output, skip
                        continue;
                    }
                }
            }
            else {
                // Log tracker failure and continue
                continue;
            }
        }
        return [...hosts];
    }
}
//# sourceMappingURL=LookupResolver.js.map